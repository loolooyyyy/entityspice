<?php print $a['php']; ?>

/**
 * @file
 * <?php print $a['machine_name']; ?>'s bundle classes.
 *
 * this file is auto-generated by EntitySpice only if the entity type has
 * support for bundles.
// TODO custom fields.
// TODO deny delete.
// TODO Entity default label.
// TODO custom fields on build content.
 */

/**
 * The class used for bundle entities
 */
class <?php echo $a['bundle entity class'] ?> extends Entity {
  const _entity_type = '<?php print $a['bundle machine name'] ?>';

  /**
   * String: Machine name of bundle entity.
   */
  public $name;

  /**
   * String: Human readable name (label) of bundle entity.
   */
  public $label;

  /**
   * Boolean: Whether deleting this bundle is allowed or not.
   */
  public $locked;

  public function __construct(array $values = []) {
    parent::__construct($values, $this::_entity_type);
  }
}

/**
 * The controller class for entity bundles contains methods for CRUD
 * operations. The load method is inherited from the default controller.
 */
class <?php print $a['bundle controller class'] ?> extends EntityAPIControllerExportable {
  const _entity_type = '<?php print $a['bundle machine name'] ?>';

  /**
   * @see parent
   */
  final public function delete($ids, DatabaseTransaction $transaction = NULL) {
    <?php if($a['bundle lock on exists'])>
    throw new RuntimeException('must check if any entity of this bundle exists, but it is not implemented yet!');
    <?php endif;>
    // TODO do not allow delete if entity exists for this bundle (configurable).
    parent::delete($ids, $transaction);
    menu_rebuild();
  }

  public function __construct() {
    parent::__construct($this::_entity_type);
  }
}


/**
 * Entity Bundle UI controller.
 */
class <?php print $a['machine_camel'] ?>BundleUIController extends EntityDefaultUIController {
  const _entity_type = '<?php print $a['type_const'] ?>';

  public function __construct($entity_info) {
    parent::__construct($this::_entity_type, $entity_info);
  }
}

/**
* Create a new bundle object - DOES NOT SAVE IT.
*
* @param array $values
*   Associative array of values. At least include ['type' => $type].
*
* @return \Entity created bundle.
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_bundle_create(array $values = []) {
  return entity_get_controller('<?php echo $a['bundle machine name'] ?>')->create($values);
}

/**
* Load a bundle entity by it's machine name.
*
* @param string $name The machine-readable name of a bundle to load.
*
* @return array.
*   An bundle entity array or FALSE if $name does not exist.
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_bundle_load($name) {
  $bundles = entity_load_multiple_by_name("<? echo $a["bundle machine name"]>", [$name]);
  foreach ($bundles as $bundle) {
    return $bundle;
  }
  throw new <?php echo $a['exception class'] >('no such bundle: ' . $name);
}

/**
* Deletes a bundle.
*
* @param entity $bundle the bundle to delete (bundle object)
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_bundle_delete($bundle) {
  $bundle->delete();
}

/**
* Saves a bundle.
*
* @param entity $bundle the bundle to save (bundle object)
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_bundle_save($bundle) {
  $bundle->save();
}

// ____________________________________________________________________________________________________________________

/**
* @see _entityspice_entity_get_bundles().
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_get_bundles() {
  return entity_load_multiple_by_name("<? echo $a["bundle machine name"]>");
}

/**
* @see _entityspice_entity_get_bundles_names().
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_get_bundles_names() {
  $bundles = <?php echo $a['safe'] . $a['machine_name'] ?>_get_bundles();
  return array_keys($bundles);
}

/**
 * TODO does it need check plain?
 */
function <?php echo $a['safe'] . $a['machine_name'] ?>_get_bundles_options_list($check_plain = TRUE) {
  $bundles = <?php echo $a['safe'] . $a['machine_name'] ?>_get_bundles();
  $ret = [];
  foreach ($bundles as $bundle => $info) {
    $ret[$bundle] = $check_plain ? check_plain($info->label) : $info->label;
  }
  return $ret;
}

/**
*/
function <?php echo $a['safe'] . $a['machine_name'] ?>_bundle_access($op, $bundle = NULL, $user = NULL) {
  throw new RuntimeException('unsupported');
}
