<?php /** @noinspection PhpDocSignatureInspection */
/** @noinspection PhpUnusedParameterInspection */
/** @noinspection PhpIncludeInspection */
/** @noinspection PhpUndefinedFunctionInspection */
/** @noinspection PhpUndefinedConstantInspection */

require_once 'entityspice_error.inc';


/**
 * This implementation does NOT call any of subclass methods. Do NOT expect
 * behaviour of a method to change, overriding some other method.
 *
 * None of methods declared in this class or implementation should take a key,
 * and nothing other than simple values indication support for a future should
 * be returned. It must be a simple immutable value class with no logic. Else,
 * it is a design error, a disaster.
 */
class EntitySpiceConfig {

  private $machine_name;

  private $label_name;

  private $camel_name_upper_first;

  /**
   * A string prepended to functions (usually underscore) to exclude them from
   * global namespace, so accidentally a hook is not implemented.
   *
   * @var string
   */
  private $safe;


  private $tokens = [];

  /**
   * @param $machine_name string machine name of entity this config belongs to.
   * @param bool $safe whether if a string prepended to functions (usually
   * underscore) to exclude them from global namespace, so accidentally a hook
   * is not implemented.
   */
  public function __construct($machine_name, $safe = TRUE) {
    if ($err = EntitySpiceToken::validate(EntitySpiceToken::MACHINE_NAME, $machine_name)) {
      throw new RuntimeException($err);
    }
    if ($err = EntitySpiceToken::validate(EntitySpiceToken::BOOL, $machine_name)) {
      throw new RuntimeException($err);
    }

    $this->machine_name = $machine_name;

    $label_name = ucwords(str_replace('_', ' ', $machine_name));
    $uc = str_replace(' ', '', $this->label_name);

    $tokens['php'] = EntitySpiceToken::non_override('php', '<' . '?' . 'php');
    $tokens['safe'] = EntitySpiceToken::non_override('safe', $safe ? '_' : '');

    $tokens['camelNameUcFirst'] = EntitySpiceToken::non_override('camelNameUcFirst', $uc);
    $tokens['camelNameLcFirst'] = EntitySpiceToken::non_override('camelNameLcFirst', lcfirst($uc));
    $tokens['sMachineName'] = EntitySpiceToken::non_override('camelNameLcFirst', $this->safe . $machine_name);
    $tokens['MachineName'] = EntitySpiceToken::non_override('camelNameLcFirst', $machine_name);

    $tokens['humanName'] = EntitySpiceToken::label('humanName', $label_name);
  }

  function idKey() {
    return "id";
  }

  function baseTable() {
    return $this->machine_name;
  }

  function isFieldable() {
    return TRUE;
  }

  function accessControlledActions() {
    return [
      'administer',
      'create',
      'delete',
      'view',
      'archive',
    ];
  }

  function hasDevelSupport() {
    return TRUE;
  }

  function hasCanDeleteHook() {
    return FALSE;
  }

  // ___________________________________________________________________ BUNDLE

  function hasBundle() {
    return TRUE;
  }

  function bundleMachineName() {
    return $this->machine_name . '_bundle';
  }

  function bundleKeyName() {
    return "bid";
  }

  function bundleTable() {
    return $this->machine_name . '_bundle';
  }

  function bundleHasLock() {
    return TRUE;
  }

  function bundleIsEntity() {
    return TRUE;
  }

  function bundleSubmitRedirect() {
    return 'admin/structure/' . $this->machine_name;
  }

  function bundleDeleteRedirect() {
    return 'admin/structure/' . $this->machine_name;
  }

  function isBundleFieldable() {
    return TRUE;
  }


  // _________________________________________________________________ REVISION

  function hasRevision() {
    return FALSE;
  }

  function revisionTable() {
    return $this->machine_name . '_revision';
  }

  function revisionKeyName() {
    return 'rid';
  }

  function hasRevisionLog() {
    return TRUE;
  }

  // _____________________________________________________________________ PATH

  function parentAdminPath() {
    $p = str_replace('_', '-', $this->machine_name);
    return 'admin/structure/' . $p;
  }

  function parentUserlandPath() {
    $p = str_replace('_', '-', $this->machine_name);
    return $p;
  }

  function entityDeleteRedirect() {
    return '/';
  }

  function uriCallback() {
    throw new RuntimeException("uriCallback");
  }


  // ______________________________________________________________________ IEF

  function hasInlineEntityFormSupport() {
    return TRUE;
  }

  // ______________________________________________________________________ ETC

  final function php() {
    return '<' . '?' . 'php';
  }

  final function all() {
    return get_class_methods('EntitySpiceConfig');
  }

  // _________________________________________________________________ OVERRIDE

  /**
   * Why use __call and so much trouble?
   *
   * Because I later realized I need this. And I'm not going to user arrays over
   * object. An object clearly defines the keys (by using methods);
   *
   * Magic getter is not used. Because F*** this ****.
   */
  function __call($name, $arguments) {
    return in_array($name, $this->override, TRUE)
      ? $this->override[$name]
      : call_user_func([$this, $name]);
  }

  function override($name, $value) {
    if (!is_string($name) || !is_string($value)) {
      throw new RuntimeException('bad data type, need string');
    }
    if (!in_array($name, $this->all(), TRUE)) {
      throw new RuntimeException('no such key: ' . $name);
    }
    if (in_array($name, $this->non_over)) {
      throw new RuntimeException('key can not be overridden: ' . $name);
    }
    $this->override[$name] = $value;
  }

  function overridable() {
    $all = $this->all();
    $none = $this->non_over;
    $diff = array_diff($all, $none);
    return $diff;
  }

  /**
   * Bad idea.
   *
   * returns an array: ['description', 'default value']
   */
  function description($name) {
    if (in_array($name, $this->non_over)) {
      return ['non overridable method', '?'];
    }

    $dummy = new EntitySpiceConfig($this->machine_name);
    switch ($name) {

      case 'safe':
        return [
          'whether if a string prepended to functions (usually ' .
          'underscore)to exclude them from global namespace, so ' .
          ' a hook is not accidentally implemented.',
          'TRUE',
        ];

      case 'camelNameLcFirst':
        return ['machineNameButLikeThis', $dummy->camelNameLcFirst()];

      case 'camelNameUcFirst':
        return ['MachineNameButLikeThis', $dummy->camelNameUcFirst()];

      case 'sMachineName':
        return [
          'safe() and machineName() concatenated. see description for [safe]',
          $dummy->sMachineName(),
        ];

      case 'machineName':
        return ['machine name for the generated entity type.', 'N/A'];

      case 'humanName':
        return [
          'human readable name (label) for the generated entity type.',
          $dummy->humanName(),
        ];

      case 'idKey':
        return [
          'id property on entity object (just like nid on $node->nid)',
          $dummy->idKey(),
        ];

      case 'baseTable':
        return [
          'name of the database table',
          $dummy->baseTable(),
        ];

      case 'isFieldable':
        return [
          'whether if generated entity type supports fields.',
          $dummy->isFieldable(),
        ];

      case 'accessControlledActions':
        return [
          'name of supported actions on entity, whose permission is ' .
          'controlled, such as view, create...',
          implode(', ', $dummy->accessControlledActions()),
        ];

      case 'hasDevelSupport':
        return [
          'whether if generated entity type directly supports devel module ' .
          '(a devel page is accessible for each entity, just like ' .
          '/node/NID/devel',
          $dummy->hasDevelSupport(),
        ];

      case 'hasCanDeleteHook':
        return [
          'whether if a hook_ENTITY_TYPE_can_delete() is added, so other ' .
          ' modules can decide and prevent an entity from being deleted',
          $dummy->hasCanDeleteHook(),
        ];

      case 'hasBundle':
        return [
          'whether if entity type support bundles',
          $dummy->hasBundle(),
        ];

      case 'bundleMachineName':
        return [
          'machine name of entity type\'s bundle, if you do not like MACHINE_NAME_bundle',
          $dummy->bundleMachineName(),
        ];

      case 'bundleKeyName':
        return [
          'name of the property denoting an entity\'s bundle, on the entity object',
          $dummy->bundleKeyName(),
        ];

      case 'bundleTable':
        return [
          'if bundle is an entity, the table holding the bundles',
          $dummy->bundleTable(),
        ];

      case 'bundleHasLock':
        return [
          'whether if bundles are lockable, so they can not be deleted',
          $dummy->bundleHasLock(),
        ];

      case 'bundleIsEntity':
        return [
          'whether if bundles are entity themselves',
          $dummy->bundleIsEntity(),
        ];

      case 'bundleSubmitRedirect':
        return [
          'the uri to redirect to, when a new bundle is saved',
          $dummy->bundleSubmitRedirect(),
        ];

      case 'bundleDeleteRedirect':
        return [
          'the uri to redirect to, when a bundle is deleted',
          $dummy->bundleDeleteRedirect(),
        ];

      case 'isBundleFieldable':
        return [
          'whether if bundles are fieldable themselves',
          $dummy->isBundleFieldable(),
        ];

      case 'hasRevision':
        return [
          'whether if the entity is revision-able',
          $dummy->hasRevision(),
        ];

      case 'revisionTable':
        return [
          'name of the table holding entity revisions',
          $dummy->revisionTable(),
        ];

      case 'revisionKeyName':
        return [
          'name of the key on entity object holding it\'s revision id',
          $dummy->revisionKeyName(),
        ];

      case 'hasRevisionLog':
        return [
          'whether if each revision has a log (stored in DB)',
          $dummy->hasRevisionLog(),
        ];

      case 'parentAdminPath':
        return [
          'the root path for entity type\'s administration pages',
          $dummy->parentAdminPath(),
        ];

      case 'parentUserlandPath':
        return [
          'the root path for entities themselves',
          $dummy->parentUserlandPath(),
        ];

      case 'entityDeleteRedirect':
        return [
          'the path to redirect to when an entity is deleted',
          $dummy->entityDeleteRedirect(),
        ];

      case 'hasInlineEntityFormSupport':
        return [
          'whether if inline entity form module is supported',
          $dummy->hasInlineEntityFormSupport(),
        ];

      case 'uriCallback':
        return ['hmm?', '??'];
    }
    throw new RuntimeException('no description for: ' . $name);
  }


  function process($name, $value) {
    switch ($name) {
      case 'accessControlledActions':
        return json_decode($value);

      case 'safe':
      case 'hasRevision':
      case 'bundleHasLock':
      case 'bundleIsEntity':
      case 'isBundleFieldable':
      case 'isFieldable':
      case 'hasDevelSupport':
      case 'hasCanDeleteHook':
      case 'hasInlineEntityFormSupport':
      case 'hasRevisionLog':
      case 'hasBundle':
        return EntitySpiceToken::validate($value, EntitySpiceToken::BOOL);

      default:
        return $value;
    }
  }

  function validate($name, $value) {
    $type = NULL;
    switch ($name) {
      case 'humanName':
        $type = EntitySpiceToken::LABEL;
        break;

      case 'idKey':
      case 'bundleKeyName':
      case 'bundleTable':
      case 'bundleMachineName':
      case 'revisionKeyName':
      case 'baseTable':
      case 'revisionTable':
        $type = EntitySpiceToken::MACHINE_NAME;
        break;

      case 'accessControlledActions':
        $type = EntitySpiceToken::FLAT_STRING_ARRAY;
        break;

      case 'safe':
      case 'hasRevision':
      case 'bundleHasLock':
      case 'bundleIsEntity':
      case 'isBundleFieldable':
      case 'isFieldable':
      case 'hasDevelSupport':
      case 'hasCanDeleteHook':
      case 'hasInlineEntityFormSupport':
      case 'hasRevisionLog':
      case 'hasBundle':
        $type = EntitySpiceToken::BOOL;
        break;

      case 'parentAdminPath':
      case 'parentUserlandPath':
      case 'bundleSubmitRedirect':
      case 'entityDeleteRedirect':
      case 'bundleDeleteRedirect':
        $type = EntitySpiceToken::URI;
        break;

      case 'uriCallback':
        $type = EntitySpiceToken::FUNC;
        break;

      default:
        $type = EntitySpiceToken::UNKNOWN;
    }

    return EntitySpiceToken::validate($value, $type);
  }

  private $non_over = [
    '__construct',
    '__call',

    'php',
    'safe',
    'camelNameLcFirst',
    'camelNameUcFirst',
    'machineName',
    'sMachineName',

    'all',
    'description',
    'overridable',
    'override',
    'validate',
    'process',
  ];

}

class EntitySpiceToken {

  const NON_OVERRIDABLE = -2;

  const UNKNOWN = -1;

  const MACHINE_NAME = 0;

  const LABEL = 1;

  const URI = 3;

  const BOOL = 3;

  const FLAT_STRING_ARRAY = 4;

  const FUNC = 5;


  var $type;

  var $name;

  var $value;


  function __construct($type, $name, $value = NULL) {
    switch ($type) {
      case EntitySpiceToken::MACHINE_NAME:
      case EntitySpiceToken::LABEL:
      case EntitySpiceToken::URI:
      case EntitySpiceToken::BOOL:
      case EntitySpiceToken::FLAT_STRING_ARRAY:
      case EntitySpiceToken::FUNC:
        break;
      default:
        throw new RuntimeException("unknown type: [$type] for [$name] value [$value]");
    }

    $this->type = $type;
    $this->name = $name;
    $this->set($value);
  }

  function set($value) {
    if (($err = EntitySpiceToken::validate($value, $this->type)) !== '') {
      throw new RuntimeException("$err");
    }
    $this->value = $value;
    return $this;
  }

  static function validate($value, $type) {
    switch ($type) {
      case NULL:
        return "null value is not valid of type [$type]";

      case EntitySpiceToken::MACHINE_NAME:
        $err = "bad [machine name]: [$value]: must match the regex: ^[a-z][_0-9a-z]*?$";
        if (!is_string($value) || empty($value) || !preg_match('#^[a-z][_0-9a-z]*?$#', $value)) {
          return $err;
        }
        break;

      case EntitySpiceToken::LABEL:
        $err = "bad [label]: [$value]";
        $err .= ": must match the regex: ^[A-Za-z][_0-9a-zA-Z ]*?$ Don't worry much you can change it later with much less restrictions.";
        if (!is_string($value) || empty($value) || !preg_match('#^[A-Za-z][_0-9a-zA-Z ]*?$#', $value)) {
          return $err;
        }
        break;

      case EntitySpiceToken::URI:
        $err = "bad [uri]: [$value] this value can be changed later.";
        if ($value === '\<front\>') {
          break;
        }
        if (!is_string($value) || empty($value)) {
          return $err;
        }
        if (conut(str_replace('/', '', $value)) === 0) {
          return $err;
        }
        if (!ctype_alnum(str_replace('/', '', $value)) === 0) {
          return $err;
        }
        if (strlen(str_replace('//', '', $value)) !== strlen($value)) {
          return $err;
        }
        break;

      case EntitySpiceToken::BOOL:
        $err = "bad [bool]: [$value]";
        $err .= ': valid boolean values: y, n, t, f, false, true, yes, no ' .
          '(any of them lower or upper case des not matter), 0, 1 (as digit' .
          ' or letter). empty is NOT a valid value.';
        if (_entityspice_v_boolean($value) === NULL) {
          return $err;
        };
        break;

      case EntitySpiceToken::FLAT_STRING_ARRAY:
        $err = 'bad [array]: array is not a valid json array, or contains non-alphanum values';
        $json = NULL;
        try {
          $json = json_decode($value);
        } catch (Exception $e) {
          return $err;
        }
        if ($json === NULL) {
          return $err;
        }
        foreach ($json as $item) {
          if (!ctype_alnum($item)) {
            return $err;
          }
        }
        break;

      case EntitySpiceToken::FUNC:
        $err = "bad [function name]: [$value]: must match the regex: ^[a-z][_0-9a-z]*?$";
        if (!is_string($value) || empty($value) || !preg_match('#^[a-z][_0-9a-z]*?$#', $value)) {
          return $err;
        }
        break;

      case EntitySpiceToken::NON_OVERRIDABLE:
        return "can not validate value of type [non-overridable]";

      case EntitySpiceToken::UNKNOWN:
        return "do not know how to validate [$value] of type [unknown]";

      default:
        return "do not know how to validate [$value] of type [$type]";
    }
    return '';
  }


  static function non_override($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::NON_OVERRIDABLE, $value);
  }

  static function unknown($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::UNKNOWN, $value);
  }

  static function machine_name($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::MACHINE_NAME, $name, $value);
  }

  static function label($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::LABEL, $name, $value);
  }

  static function uri($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::URI, $name, $value);
  }

  static function bool($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::BOOL, $name, $value);
  }

  static function arr($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::FLAT_STRING_ARRAY, $name, $value);
  }

  static function func($name, $value) {
    return new EntitySpiceToken(EntitySpiceToken::FUNC, $name, $value);
  }

}


function _entityspice_validate_machine_name($machine_name) {
  if (empty($machine_name)
    || !is_string($machine_name)
    || !ctype_alnum($machine_name)
    || ctype_digit($machine_name[0])
    || !ctype_lower($machine_name)
    || $machine_name[0] === '_') {
    return "bad machine name: [$machine_name]";
  }
  return NULL;
}

function _entityspice_validate_safe_string($value) {
}

function _entityspice_v_boolean($value) {
  $yes = ['y', 'yes', 't', 'true', '1', 1, TRUE];
  $no = ['n', 'no', 'f', 'false', '0', 0, FALSE];
  if (in_array($value, $yes, TRUE)) {
    return TRUE;
  }
  if (in_array($value, $no, TRUE)) {
    return FALSE;
  }
  return NULL;
}


/**
 * Implements hook_drush_help().
 *
 * @param $section
 */
function entityspice_drush_help($section) {
  // @TODO
}

/**
 * Implements hook_drush_command().
 */
function entityspice_drush_command() {
  $items['entityspice - cook'] = [
    'aliases' => ['cook'],
    'callback' => '_entityspice_drush_pre_ekran',
    'description' => 'Create a module containing an entity(cook an entity type).',
    'arguments' => ['machine - name' => 'Machine name of generated entity . '],
    'options' => [],
    'examples' => [],
    'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_FULL,
  ];
  $dummy = new EntitySpiceConfig('dummy');
  foreach ($dummy->overridable() as $name => $token) {
    if ($name !== 'machine_name') {
      $items['entityspice - cook']['options'][$name] = $token[0];
    }
  }
  return $items;
}

/**
 * Asks user for yes or no and parse input.
 *
 * Accepts all forms of yes and no, y, Y, 1, t, true, TRUE, false, FALSE, ...
 *
 * @param string $msg message to display as prompt.
 *
 * @return bool true if user said yes false otherwise.
 */
function _entityspice_drush_presume($msg) {
  drush_print_prompt($msg . " (Y/n): ", 0);
  if (drush_get_context('DRUSH_AFFIRMATIVE')) {
    // Automatically accept confirmations if the --yes argument was supplied.
    drush_print("y");
    return TRUE;
  }
  elseif (drush_get_context('DRUSH_NEGATIVE')) {
    // Automatically cancel confirmations if the --no argument was supplied.
    drush_print("n");
    return FALSE;
  }
  else {
    $stdin = fopen("php://stdin", "r");
    while ($line = fgets($stdin)) {
      $line = strtolower(trim($line));
      if (empty($line) || $line === 'y' || $line === 1 || $line[0] === 't' || $line === '1') {
        return TRUE;
      }
      if ($line === 'n' || $line === 0 || $line[0] === 'f' || $line === '0') {
        return FALSE;
      }
      drush_print_prompt($msg . " (Y/n): ", 0);
    }
  }
  return FALSE;
}

/**
 * drush command callback.
 *
 * @param string $machine_name
 *
 * @return bool true on success, false otherwise.
 * @throws \Exception
 */
function _entityspice_drush_pre_ekran($machine_name = NULL) {
  if ($err = _entityspice_validate_machine_name($machine_name)) {
    drush_set_error($err);
    return FALSE;
  }
  if (module_exists($machine_name)) {
    drush_set_error("a module named [$machine_name] already exists");
    return FALSE;
  }

  // ================================================== Handle drush cli options
  $already = [];
  $cfg = new EntitySpiceConfig($machine_name);
  foreach ($cfg->overridable() as $name) {
    // Machine name is already set by a mandatory argument.
    $arg = drush_get_option($name, NULL);
    if ($arg === NULL) {
      continue;
    }
    if ($err = $cfg->validate($name, $arg)) {
      drush_set_error("bad value for [$name] : [$arg] : [err msg if any: $err]");
      return FALSE;
    }
    else {
      $cfg->override($name, $arg);
      $already[] = $name;
    }
  }

  // ======================================================= Handle drush prompt
  if (!_entityspice_drush_presume('do you want to use default options ? ')) {
    drush_log('Enter "?" to see each arguments help, ' .
      'leave empty for default value . ' . "\n", 'ok');
    foreach ($cfg->overridable() as $token) {
      if (in_array($token, $already)) {
        continue;
      }
      $desc = $cfg->description($token);
      while (TRUE) {
        $value = drush_prompt($token . ' (? for help)
            ',
          $desc[1],
          TRUE);
        if ($value === ' ? ') {
          drush_log($token['description'] . "\n", 'ok');
          continue;
        }
        $value = _entityspice_token_post_process($token['validation_policy'], $value);
        if ($err = $cfg->validate($token, $value)) {
          drush_log(_entityspice_error_msg($err), 'error');
        }
        else {
          $cfg->override($token, $cfg->process($token, $value));
          break;
        }
      };
    }
  }

  // ===================================================================== EKRAN
  $dest = _entityspice_pm_download_destination('module') . ' / ' . $machine_name;
  if (is_dir($dest)) {
    drush_set_error("destination already exists: $dest, installing into an existing" .
      ' destination is dangerous and not supported');
    return FALSE;
  }

  $tmp = drush_tempdir() . ' / ' . $machine_name;
  if (!drush_mkdir($tmp)) {
    drush_log('could not mkdir tmp directory: ' . $tmp);
    return FALSE;
  }
  if ($err = _entityspice_ekran($tmp, $cfg)) {
    drush_log("failed: $err", 'error');
    return FALSE;
  }

  if (!drush_move_dir($tmp, $dest)) {
    drush_log("could not mv $tmp to $dest", 'error');
    return FALSE;
  }

  drush_log('FIN, your beautiful entity type is generated at: ' . $dest, 'ok');
  return TRUE;
}

// _______________________________________________________________________ MAIN

/**
 * Before calling:
 *  - ensure valid machine name.
 *  - ensure no module with that machine name exist.
 *  - ensure all token values are provided.
 *  - ensure all tokens have valid values.
 */
function _entityspice_render(EntitySpiceConfig $a) {
  $files = [];
  foreach ([
             'access . inc',
             'admin . inc',
             'bundle .class.inc',
             'class.inc',
             'dev . inc',
             'display . inc',
             'entity . inc',
             'info',
             'inline_entity_form . inc',
             'install',
             'menu . inc',
             'module',
           ] as $f) {
    if ($f === 'bundle .class.inc' && !$a->hasBundle()) {
      continue;
    }
    if ($f === 'inline_entity_form . inc' && !$a->hasInlineEntityFormSupport()) {
      continue;
    }
    if ($f === 'dev . inc' && !$a->hasDevelSupport()) {
      continue;
    }

    ob_start();
    require "template/PLACEHOLDER.$f.tpl";
    $files[$a->machineName() . ' . ' . $f] = ob_get_contents();
    ob_end_clean();
  }
  return $files;
}

// -----------

/**
 * Stolen from drush pm-download, to find where to put generated module in.
 *
 * So that there is no hard dependency on drush.
 *
 * Only used by function _entityspice_pm_download_destination().
 */
function _entityspice_pm_download_destination_lookup($type, $drupal_root, $sitepath, $create = FALSE) {
  $destination = $type . 's';
  // Prefer /contrib if it exists.
  if ($sitepath) {
    $destination = $sitepath . ' / ' . $destination;
  }
  $contrib = $destination . ' / contrib';
  if (is_dir($contrib)) {
    $destination = $contrib;
  }
  if ($create) {
    drush_log(dt('Attempting to create destination directory at !dir', ['!dir' => $destination]));
    drush_mkdir($destination, TRUE);
  }
  if (is_dir($destination)) {
    drush_log(dt('Using destination directory !dir', ['!dir' => $destination]));
    return $destination;
  }
  drush_log(dt('Could not find destination directory at !dir', ['!dir' => $destination]));
  return FALSE;
}

/**
 * Stolen from drush pm-download, to find where to put generated module in.
 *
 * So that there is no hard dependency on drush.
 */
function _entityspice_pm_download_destination($type) {
  $drupal_root = drush_get_context('DRUSH_DRUPAL_ROOT');
  $site_root = drush_get_context('DRUSH_DRUPAL_SITE_ROOT');
  $full_site_root = (empty($drupal_root) || empty($site_root)) ? '' : $drupal_root . ' / ' . $site_root;
  $sitewide = empty($drupal_root) ? '' : $drupal_root . ' / ' . drush_drupal_sitewide_directory();

  $in_site_directory = FALSE;
  // Check if we are running within the site directory.
  if (strpos(realpath(drush_cwd()), realpath($full_site_root)) !== FALSE || (drush_get_option('use-site - dir', FALSE))) {
    $in_site_directory = TRUE;
  }

  $destination = '';
  // Attempt 1: If we are in a specific site directory, and the destination
  // directory already exists, then we use that.
  if (empty($destination) && $site_root && $in_site_directory) {
    $create_dir = drush_get_option('use-site - dir', FALSE);
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $full_site_root, $create_dir);
  }
  // Attempt 2: If the destination directory already exists for
  // the sitewide directory, use that.
  if (empty($destination) && $drupal_root) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $sitewide);
  }
  // Attempt 3: If a specific (non default) site directory exists and
  // the sitewide directory does not exist, then create destination
  // in the site specific directory.
  if (empty($destination) && $site_root && $site_root !== 'sites /default' && is_dir($full_site_root) && !is_dir($sitewide)) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $full_site_root, TRUE);
  }
  // Attempt 4: If sitewide directory exists, then create destination there.
  if (empty($destination) && is_dir($sitewide)) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $sitewide, TRUE);
  }
  // Attempt 5: If site directory exists (even default), then create
  // destination in that directory.
  if (empty($destination) && $site_root && is_dir($full_site_root)) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $full_site_root, TRUE);
  }
  // Attempt 6: If we didn't find a valid directory yet(or we somehow found
  // one that doesn't exist) we always fall back to the current directory.
  if (empty($destination) || !is_dir($destination)) {
    $destination = drush_cwd();
  }

  return $destination;
}

function _entityspice_ekran($target_dir, EntitySpiceConfig $tokens) {
  if (defined('DRUSH_BOOTSTRAP_DRUPAL')) {
    if (!drush_op('chdir', $target_dir)) {
      return 'could not chdir into target: ' . $target_dir;
    }
    foreach (_entityspice_render($tokens) as $file => $text) {
      $f = drush_op('fopen', 'w', $file);
      if (!$f) {
        drush_log('warning', 'could not open file for writing, dry_run? -> ' . $file);
        continue;
      }
      drush_op('fwrite', $f, $text);
      drush_op('fclose', $f);
    }
    return '';
  }
  else {
    if (!chdir($target_dir)) {
      return 'could not chdir into target: ' . $target_dir;
    }
    foreach (_entityspice_render($tokens) as $file => $text) {
      $f = fopen($file, 'w');
      if (!$f) {
        return "could not create file: $file";
      }
      fwrite($f, $text);
      fclose($f);
    }
    return '';
  }
}
