<?php /** @noinspection PhpDocSignatureInspection */
/** @noinspection PhpUnusedParameterInspection */
/** @noinspection PhpIncludeInspection */
/** @noinspection PhpUndefinedFunctionInspection */
/** @noinspection PhpUndefinedConstantInspection */

require_once 'entityspice_error.inc';


/**
 * This implementation does NOT call any of subclass methods. Do NOT expect
 * behaviour of a method to change, overriding some other method.
 *
 * None of methods declared in this class or implementation should take a key,
 * and nothing other than simple values indication support for a future should
 * be returned. It must be a simple immutable value class with no logic. Else,
 * it is a design error, a disaster.
 */
class ESConfig {

  private $t;

  /**
   * @param $machine_name string machine name of entity this config belongs to.
   * @param bool $safe whether if a string prepended to functions (usually
   * underscore) to exclude them from global namespace, so accidentally a hook
   * is not implemented.
   */
  public function __construct($machine_name, $safe = TRUE) {
    ESToken::machine_name('machine_name', $machine_name)->validate();
    ESToken::bool('safe', $safe)->validate();

    $tokens['php'] = ESToken::non_override('php', '<' . '?' . 'php');
    $tokens['safe'] = ESToken::non_override('safe', $safe ? '_' : '');
    $tokens['machine_name'] = ESToken::non_override('machine_name', $machine_name);
    $tokens['s_machine_name'] = ESToken::non_override(
      'sMachineName',
      ($safe ? '_' : '') . $machine_name,
      'namespace-safe machine name');
    $tokens['sane'] = ESToken::non_override(
      'sane',
      ($safe ? '_' : '') . $machine_name,
      'namespace-safe machine name');


    $tokens['human_name'] = ESToken::label(
      'human_name',
      ucwords(str_replace('_', ' ', $machine_name)),
      'human readable name, aka label.');

    $uc = str_replace(' ', '', $tokens['human_name']->value);
    $tokens['uc'] = ESToken::non_override('uc', $uc, 'upper case first, machine camel name');
    $tokens['lc'] = ESToken::non_override('lc', lcfirst($uc), 'lower case first, machine camel name');

    $tokens['id_key'] = ESToken::machine_name(
      'id_key',
      'id',
      'id key, on entity object, just like nid on $node->nid');
    $tokens['base_table'] = ESToken::machine_name(
      'base_table',
      $machine_name,
      'database table name');
    $tokens['is_fieldable'] = ESToken::bool(
      'is_fieldable',
      TRUE,
      'whether if this is a fieldable entity type, or a non-fieldable one');

    $tokens['access_controlled_actions'] = ESToken::arr(
      'access_controlled_actions',
      [
        'administer',
        'create',
        'delete',
        'view',
        'archive',
      ],
      'actions on the entity, which are controlled by permission, just like ' .
      'node creation, node view, ...; ONLY PROVIDE THE VERB, such as [view] or' .
      ' [create] or ... (view own is added automatically)');

    $tokens['has_devel_support'] = ESToken::bool(
      'has_devel_support',
      TRUE,
      'whether if this entity type has special support for devel module, just like node/%nid/devel');
    $tokens['has_can_delete_hook'] = ESToken::bool(
      'has_can_delete_hook',
      TRUE,
      'whether if a can_delete_hook is added, so other modules can lock ' .
      'entities of this type and prevent deletion');

    $e_path = str_replace('_', '-', $machine_name);

    $tokens['has_bundle'] = ESToken::bool(
      'has_bundle',
      TRUE,
      'whether if this entity type supports bundles, just like node types');
    $tokens['bundle_machine_name'] = ESToken::machine_name(
      'bundle_machine_name',
      $machine_name . '_bundle');
    $tokens['bundle_key_name'] = ESToken::machine_name(
      'bundle_key_name',
      'bid',
      'bundle key name on entity object just like [type] on node objects');
    $tokens['bundle_table'] = ESToken::machine_name(
      'bundle_table',
      $machine_name . '_bundle',
      'the table holding entity bundles in database');
    $tokens['bundle_has_lock'] = ESToken::bool(
      'bundle_has_lock',
      TRUE,
      'whether if bundles are lockable and deletion can be prevented, ' .
      'such as when entities of this bundle still exist');
    $tokens['bundle_is_entity'] = ESToken::bool(
      'bundle_is_entity',
      TRUE,
      'whether if bundles are entity themselves');

    // probably should change to parent admin path, but then we need a
    // isOverridden flag to not change it then, which will blow up the whole
    // token logic and all. so just forget it.
    $tokens['bundle_redirect'] = ESToken::uri(
      'bundle_redirect',
      'admin/structure/' . $e_path,
      'the path to redirect user to, after when a new bundle is created or removed');
    $tokens['is_bundle_fieldable'] = ESToken::bool(
      'is_bundle_fieldable',
      TRUE,
      'whether if bundles are fieldable themselves');

    $tokens['has_revision'] = ESToken::bool(
      'has_revision',
      FALSE,
      'whether if the entity type supports revisions, just like node revisions');
    $tokens['revision_table'] = ESToken::machine_name(
      'revision_table',
      $machine_name . '_revision',
      'the table holding entity revisions in database');
    $tokens['revision_key_name'] = ESToken::machine_name(
      'revision_key_name',
      'rid',
      'revision key name on entity object just like [rid] on node objects');
    $tokens['has_revision_log'] = ESToken::bool(
      'has_revision_log',
      TRUE,
      'whether if the entity type has revision logs just like node');

    $tokens['parent_admin_path'] = ESToken::uri(
      'parent_admin_path',
      'admin/structure/' . $e_path
    );
    $tokens['parent_userland_path'] = ESToken::uri(
      'parent_userland_path',
      $e_path,
      'the path on which list of entities are accessible, just like /node'
    );
    $tokens['entity_delete_redirect_path'] = ESToken::uri(
      'entity_delete_redirect_path',
      $e_path,
      'the path to redirect the user to, when an entity is deleted. A more complex logic can be later added in code.'
    );

    $tokens['has_inline_entity_form_support'] = ESToken::bool(
      'has_inline_entity_form_support',
      TRUE,
      'whether if InlineEntityForm module is supported.');

    $this->t = $tokens;
  }

  function uriCallback() {
    throw new RuntimeException("uriCallback");
  }

  // _________________________________________________________________ OVERRIDE

  function __get($name) {
    if ($name === 'php') {
      return '<' . '?php';
    }
    if ($name === 's') {
      $name = 'sane';
    }
    if ($name === 'm') {
      $name = 'machine_name';
    }
    foreach ($this->t as $token) {
      if ($name === $token->name) {
        //        echo "haha [" . $token->name . "][" . $token->value . "][" . $token->type . "]\n";
        return $token->type === ESToken::NON_OVERRIDABLE ? $token->value : $token;
      }
    }
    throw new RuntimeException("no such token: [$name]");
  }

  function __set($name, $value) {
    $this->__get($name)->set($value)->validate();
  }

  function names() {
    $ret = [];
    foreach ($this->t as $name => $token) {
      if ($token->type !== ESToken::NON_OVERRIDABLE) {
        $ret[] = $name;
      }
    }
    return $ret;
  }

}

class ESToken {

  const NON_OVERRIDABLE = 0;

  const UNKNOWN = 1;

  const MACHINE_NAME = 2;

  const LABEL = 3;

  const URI = 4;

  const BOOL = 5;

  const FLAT_STRING_ARRAY = 6;

  const FUNC = 7;


  private $type;

  private $name;

  private $value;

  private $desc;


  function __construct($type, $name, $value = NULL, $desc = NULL) {
    if ($type < 0 || $type > 7) {
      throw new RuntimeException("unknown type: [$type] for [$name] with value [$value]");
    }
    $this->type = $type;
    $this->name = $name;
    $this->set($value);
    $this->desc = $desc;
  }

  function set($value) {
    $this->value = $value;
    return $this;
  }

  function get() {
    return $this->type === ESToken::FLAT_STRING_ARRAY ? json_decode($this->value) : $this->value;
  }

  function __get($name) {
    if (!in_array($name, [
      'value',
      'name',
      'type',
      'desc',
      'isValid',
      'error',
    ], TRUE)) {
      throw new RuntimeException('can not access any property other than name, type, value, desc, isValid and error');
    }
    switch ($name) {
      case 'type':
        return $this->type;

      case 'name':
        return $this->name;

      case 'value':
        return $this->get();

      case 'desc':
        return $this->desc;

      case 'error':
        return $this->error();

      case 'isValid':
        return $this->isValid();

      default:
        throw new RuntimeException('unknown property: ' . $name);
    }
  }


  function validate() {
    if ($err = self::check($this->value, $this->type)) {
      throw new RuntimeException($err);
    }
    return $this;
  }

  private function isValid() {
    return $this->error() ? FALSE : TRUE;
  }

  private function error() {
    return self::check($this->value, $this->type);
  }


  static function check($value, $type, $name = NULL) {
    if ($value === NULL) {
      $err = "$type::$name -> [null] is not valid";
      return $err;
    }
    if ($type === ESToken::MACHINE_NAME) {
      $regex = '/^[a-z][_0-9a-z]*?$/';
      $err = "MACHINE_NAME::$name -> [$value] must match the regex: $regex";
      if (!is_string($value) || empty($value) || !preg_match($regex, $value)) {
        return $err;
      }
    }
    elseif ($type === ESToken::LABEL) {
      $regex = '/^[A-Za-z][_0-9a-zA-Z ]*?$/';
      $err = "LABEL::$name -> [$value] must match the regex: $regex. " .
        " Labels are constrained for now BUT can be changed later (after the module is generated)";
      if (!is_string($value) || empty($value) || !preg_match($regex, $value)) {
        return $err;
      }
    }
    elseif ($type === ESToken::URI) {
      // TODO make this better and more rigorous? or perhaps it doesn't matteR?
      $err = "URI::$name -> [$value] is not a valid uri. " .
        " URIs are constrained for now BUT can be changed later (after the module is generated)";
      if ($value === '\<front\>') {
        return '';
      }
      if (!is_string($value) || empty($value)) {
        return $err;
      }
      if (conut(str_replace('/', '', $value)) === 0) {
        return $err;
      }
      if (!ctype_alnum(str_replace('/', '', $value)) === 0) {
        return $err;
      }
      if (strlen(str_replace('//', '', $value)) !== strlen($value)) {
        return $err;
      }
    }
    elseif ($type === ESToken::BOOL) {
      $err = "BOOL::$name -> [$value] is not a valid boolean. valid values: " .
        'y, n, t, f, false, true, yes, no, 0, 1 as digit or string ' .
        '(strings can be upper or lower case). empty is NOT valid';
      if (_entityspice_v_boolean($value) === NULL) {
        return $err;
      };
    }
    elseif ($type === ESToken::FLAT_STRING_ARRAY) {
      $err = "ARRAY::$name -> [$value] must be a valid FLAT json ARRAY (not map), containing only ascii alpha-num.";
      $json = NULL;
      try {
        $json = json_decode($value);
      } catch (Exception $e) {
        return $err;
      }
      if ($json === NULL) {
        return $err;
      }
      $i = 0;
      foreach ($json as $index => $item) {
        if ($i != $index) {
          return $err;
        }
        $i++;
        if (!ctype_alnum($item)) {
          return $err;
        }
      }
    }
    elseif ($type === ESToken::FUNC) {
      $regex = '/^[a-z][_0-9a-z]*?$/';
      $err = "FUNCTION_NAME::$name -> [$value] must match the regex: $regex";
      if (!is_string($value) || empty($value) || !preg_match($regex, $value)) {
        return $err;
      }
    }
    elseif ($type === ESToken::NON_OVERRIDABLE) {
      $err = "NON_OVERRIDABLE::$name -> [$value] can not be overridden.";
      return $err;
    }
    else {
      $err = "UNKNOWN::$name -> [$value] do not know how to validate.";
      return $err;
    }
    return '';
  }


  static function non_override($name, $value, $desc = NULL) {
    return new ESToken(ESToken::NON_OVERRIDABLE, $name, $value, $desc);
  }

  static function unknown($name, $value, $desc = NULL) {
    return new ESToken(ESToken::UNKNOWN, $value, $desc);
  }

  static function machine_name($name, $value, $desc = NULL) {
    return new ESToken(ESToken::MACHINE_NAME, $name, $value, $desc);
  }

  static function label($name, $value, $desc = NULL) {
    return new ESToken(ESToken::LABEL, $name, $value, $desc);
  }

  static function uri($name, $value, $desc = NULL) {
    return new ESToken(ESToken::URI, $name, $value, $desc);
  }

  static function bool($name, $value, $desc = NULL) {
    return new ESToken(ESToken::BOOL, $name, $value, $desc);
  }

  static function arr($name, $value, $desc = NULL) {
    return new ESToken(ESToken::FLAT_STRING_ARRAY, $name, $value, $desc);
  }

  static function func($name, $value, $desc = NULL) {
    return new ESToken(ESToken::FUNC, $name, $value, $desc);
  }

}

function _entityspice_v_boolean($value) {
  if (is_string($value)) {
    $value = trim(strtolower($value));
  }
  $yes = ['y', 'yes', 't', 'true', '1', 1, TRUE];
  $no = ['n', 'no', 'f', 'false', '0', 0, FALSE];
  if (in_array($value, $yes, TRUE)) {
    return TRUE;
  }
  if (in_array($value, $no, TRUE)) {
    return FALSE;
  }
  return NULL;
}


/**
 * Implements hook_drush_help().
 *
 * @param $section
 */
function entityspice_drush_help($section) {
  // @TODO
}

/**
 * Implements hook_drush_command().
 */
function entityspice_drush_command() {
  $items['entityspice-cook'] = [
    'aliases' => ['cook'],
    'callback' => '_entityspice_drush_pre_ekran',
    'description' => 'Create a module containing an entity(cook an entity type).',
    'arguments' => ['machine - name' => 'Machine name of generated entity . '],
    'options' => [],
    'examples' => [],
    'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_FULL,
  ];
  $dummy = new ESConfig('dummy');
  foreach ($dummy->names() as $name) {
    $items['entityspice-cook']['options'][$name] = $dummy->{$name}->desc;
  }
  return $items;
}

/**
 * Asks user for yes or no and parse input.
 *
 * Accepts all forms of yes and no, y, Y, 1, t, true, TRUE, false, FALSE, ...
 *
 * @param string $msg message to display as prompt.
 *
 * @return bool true if user said yes false otherwise.
 */
function _entityspice_drush_presume($msg) {
  drush_print_prompt($msg . " (Y/n): ", 0);
  if (drush_get_context('DRUSH_AFFIRMATIVE')) {
    // Automatically accept confirmations if the --yes argument was supplied.
    drush_print("y");
    return TRUE;
  }
  elseif (drush_get_context('DRUSH_NEGATIVE')) {
    // Automatically cancel confirmations if the --no argument was supplied.
    drush_print("n");
    return FALSE;
  }
  else {
    $stdin = fopen("php://stdin", "r");
    while ($line = fgets($stdin)) {
      $answer = _entityspice_v_boolean($line);
      if (empty($line) || $line === "\n" || $answer === TRUE) {
        return TRUE;
      }
      if ($answer === FALSE) {
        return FALSE;
      }
      drush_print_prompt($msg . " (Y/n): ", 0);
    }
  }
  return FALSE;
}

/**
 * drush command callback.
 *
 * @param string $machine_name
 *
 * @return bool true on success, false otherwise.
 * @throws \Exception
 */
function _entityspice_drush_pre_ekran($machine_name = NULL) {
  if ($err = ESToken::machine_name('machine_name', $machine_name)->error) {
    drush_set_error($err);
    return FALSE;
  }
  if (module_exists($machine_name)) {
    drush_set_error("a module named [$machine_name] already exists");
    return FALSE;
  }

  // ================================================== Handle drush cli options
  $already = [];
  $cfg = new ESConfig($machine_name);
  foreach ($cfg->names() as $name) {
    $arg = drush_get_option($name, NULL);
    if ($arg === NULL) {
      continue;
    }
    $already[] = $name;
    if ($err = $cfg->{$name}->set($arg)->error) {
      drush_set_error($err);
      return FALSE;
    }
  }

  // ======================================================= Handle drush prompt
  if (!_entityspice_drush_presume('do you want to use default options ? ')) {
    drush_log('Enter "?" to see each arguments help, ' .
      "leave empty for default value\n", 'ok');
    foreach ($cfg->names() as $name) {
      if (in_array($name, $already, TRUE)) {
        continue;
      }
      $desc = $cfg->{$name}->desc;
      $def = $cfg->{$name}->desc;
      while (TRUE) {
        $value = drush_prompt($name . ' (? for help) ', $def, TRUE);
        if ($value === ' ? ') {
          drush_log($desc . "\n", 'ok');
          continue;
        }
        if ($err = $cfg->{$name}->set($value)->error) {
          drush_log($err, 'error');
        }
        else {
          break;
        }
      };
    }
  }

  foreach ($cfg->names() as $name) {
    drush_log($name . ': ' . $cfg->{$name}->value, 'ok');
  }

  // ===================================================================== EKRAN
  $dest = _entityspice_pm_download_destination('module') . '/' . $machine_name;
  if (is_dir($dest)) {
    drush_set_error("destination already exists: $dest, installing into an existing" .
      ' destination is dangerous and not supported');
    return FALSE;
  }

  $tmp = drush_tempdir() . '/' . $machine_name;
  if (!drush_mkdir($tmp)) {
    drush_log('could not mkdir tmp directory: ' . $tmp);
    return FALSE;
  }
  if ($err = _entityspice_ekran($tmp, $cfg)) {
    drush_log("failed: $err", 'error');
    return FALSE;
  }

  if (!drush_move_dir($tmp, $dest)) {
    drush_log("could not mv $tmp to $dest", 'error');
    return FALSE;
  }

  drush_log('FIN, your beautiful entity type is generated at: ' . $dest, 'ok');
  return TRUE;
}

// _______________________________________________________________________ MAIN

/**
 * Stolen from drush pm-download, to find where to put generated module in.
 *
 * So that there is no hard dependency on drush.
 *
 * Only used by function _entityspice_pm_download_destination().
 */
function _entityspice_pm_download_destination_lookup($type, $drupal_root, $sitepath, $create = FALSE) {
  $destination = $type . 's';
  // Prefer /contrib if it exists.
  if ($sitepath) {
    $destination = $sitepath . ' / ' . $destination;
  }
  $contrib = $destination . ' / contrib';
  if (is_dir($contrib)) {
    $destination = $contrib;
  }
  if ($create) {
    drush_log(dt('Attempting to create destination directory at !dir', ['!dir' => $destination]));
    drush_mkdir($destination, TRUE);
  }
  if (is_dir($destination)) {
    drush_log(dt('Using destination directory !dir', ['!dir' => $destination]));
    return $destination;
  }
  drush_log(dt('Could not find destination directory at !dir', ['!dir' => $destination]));
  return FALSE;
}

/**
 * Stolen from drush pm-download, to find where to put generated module in.
 *
 * So that there is no hard dependency on drush.
 */
function _entityspice_pm_download_destination($type) {
  $drupal_root = drush_get_context('DRUSH_DRUPAL_ROOT');
  $site_root = drush_get_context('DRUSH_DRUPAL_SITE_ROOT');
  $full_site_root = (empty($drupal_root) || empty($site_root)) ? '' : $drupal_root . ' / ' . $site_root;
  $sitewide = empty($drupal_root) ? '' : $drupal_root . ' / ' . drush_drupal_sitewide_directory();

  $in_site_directory = FALSE;
  // Check if we are running within the site directory.
  if (strpos(realpath(drush_cwd()), realpath($full_site_root)) !== FALSE || (drush_get_option('use-site - dir', FALSE))) {
    $in_site_directory = TRUE;
  }

  $destination = '';
  // Attempt 1: If we are in a specific site directory, and the destination
  // directory already exists, then we use that.
  if (empty($destination) && $site_root && $in_site_directory) {
    $create_dir = drush_get_option('use-site - dir', FALSE);
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $full_site_root, $create_dir);
  }
  // Attempt 2: If the destination directory already exists for
  // the sitewide directory, use that.
  if (empty($destination) && $drupal_root) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $sitewide);
  }
  // Attempt 3: If a specific (non default) site directory exists and
  // the sitewide directory does not exist, then create destination
  // in the site specific directory.
  if (empty($destination) && $site_root && $site_root !== 'sites /default' && is_dir($full_site_root) && !is_dir($sitewide)) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $full_site_root, TRUE);
  }
  // Attempt 4: If sitewide directory exists, then create destination there.
  if (empty($destination) && is_dir($sitewide)) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $sitewide, TRUE);
  }
  // Attempt 5: If site directory exists (even default), then create
  // destination in that directory.
  if (empty($destination) && $site_root && is_dir($full_site_root)) {
    $destination = _entityspice_pm_download_destination_lookup($type, $drupal_root, $full_site_root, TRUE);
  }
  // Attempt 6: If we didn't find a valid directory yet(or we somehow found
  // one that doesn't exist) we always fall back to the current directory.
  if (empty($destination) || !is_dir($destination)) {
    $destination = drush_cwd();
  }

  return $destination;
}

function _entityspice_ekran($target_dir, ESConfig $tokens) {
  if (defined('DRUSH_BOOTSTRAP_DRUPAL')) {
    if (!drush_op('chdir', $target_dir)) {
      return 'could not chdir into target: ' . $target_dir;
    }
    foreach (_entityspice_render($tokens) as $file => $text) {
      $f = drush_op('fopen', 'w', $file);
      if (!$f) {
        drush_log('warning', 'could not open file for writing, dry_run? -> ' . $file);
        continue;
      }
      drush_op('fwrite', $f, $text);
      drush_op('fclose', $f);
    }
    return '';
  }
  else {
    if (!chdir($target_dir)) {
      return 'could not chdir into target: ' . $target_dir;
    }
    foreach (_entityspice_render($tokens) as $file => $text) {
      $f = fopen($file, 'w');
      if (!$f) {
        return "could not create file: $file";
      }
      fwrite($f, $text);
      fclose($f);
    }
    return '';
  }
}

/**
 * Before calling:
 *  - ensure valid machine name.
 *  - ensure no module with that machine name exist.
 *  - ensure all token values are provided.
 *  - ensure all tokens have valid values.
 */
function _entityspice_render(ESConfig $a) {
  $files = [];
  foreach ([
             'access.inc',
             'admin.inc',
             'bundle.class.inc',
             'class.inc',
             'dev.inc',
             'display.inc',
             'entity.inc',
             'info',
             'inline_entity_form.inc',
             'install',
             'menu.inc',
             'module',
           ] as $f) {
    if ($f === 'bundle.class.inc' && !$a->has_bundle->value) {
      continue;
    }
    if ($f === 'inline_entity_form.inc' && !$a->has_inline_entity_form_support->value) {
      continue;
    }
    if ($f === 'dev.inc' && !$a->has_devel_support->value) {
      continue;
    }

    ob_start();
    require "template/PLACEHOLDER.$f.tpl";
    $files[$a->m . '.' . $f] = ob_get_contents();
    ob_end_clean();
  }
  return $files;
}
